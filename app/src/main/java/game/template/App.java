/*
 * This Java source file was generated by the Gradle 'init' task.
 */

 
 //dir
 //you have to use this code to run it
 //./gradlew clean build run
 //have 2 save everytime you change something 



package game.template;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.text.*;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;

//panel
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.stage.Stage;
import java.util.Optional;
import java.io.BufferedWriter;
import java.io.FileWriter;
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.scene.control.ChoiceDialog;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;


//load save
import java.io.BufferedReader;
import java.io.FileReader;


public class App extends Application
{
    private VBox root;
    private StackPane table;
    private int width = 800;
    private int height = 600;
    
    //gameState
    private GameState state;

    //text
    private Text valueText;
    private Text gameStateText;
    private Text aiLastMove;
    private Text aiBetAmountText;
    private Text playerBetAmountText;
    private Text balanceText;
    
    //buttons
    private Button dealButton;
    private Button betButton;
    private Button checkButton;
    private Button raiseButton;
    private Button callButton;
    private Button foldButton;

    @Override
    public void start(Stage primaryStage) throws Exception
    {
        //System.out.println("Random print line");
        root = new VBox();
        state = new GameState(); //TODO: make be declaired in a tab
        System.out.println(state.toString());

        // menubar
        root.getChildren().add(createMenuBar());

        // mouse handler
        addMouseHandler(state);
        //key handler
        addKeyHandler(); 

        table = new StackPane();
        root.getChildren().add(table);

        // don't give a width or height to the scene
        //Scene scene = new Scene(root);
        Scene scene = new Scene(root, width, height);

        URL styleURL = getClass().getResource("/style.css");
        String stylesheet = styleURL.toExternalForm();
        scene.getStylesheets().add(stylesheet);
        primaryStage.setTitle("Play Poker like it's 2004");
        primaryStage.setScene(scene);
        primaryStage.show();

        primaryStage.setOnCloseRequest(event -> {
            System.out.println("oncloserequest");
        });

        //System.out.printf("center of stackpane  %f, %f\n", table.getWidth() / 2, table.getHeight() / 2);

        //text
        //pokerState text
        //gameStateText = new Text("Current Game State: " + state.getPokerState());
        //gameStateText.getStyleClass().add("text-display"); // Apply CSS class
        //root.getChildren().add(gameStateText); // Add text to the scene
        //aiValue and playerValue text
        //valueText = new Text("AI Value: " + state.getAiValue() + " | Player Value: " + state.getPlayerValue());
        //valueText.getStyleClass().add("text-display"); // Apply CSS class
       // root.getChildren().add(valueText); // Add text to the scene 
        //Ai last turn text
        aiLastMove = new Text("");
        aiLastMove.getStyleClass().add("text-display"); // Apply CSS class
        //balance 
        balanceText = new Text("Balance: " + state.getBalance());
        balanceText.getStyleClass().add("text-display"); // Apply CSS class
        root.getChildren().add(balanceText); // Add text to the scene
        //bet amount of each
        aiBetAmountText = new Text("Opponent bet amount: " + state.getAiBetAmount());
        aiBetAmountText.getStyleClass().add("text-display"); // Apply CSS class
        root.getChildren().add(aiBetAmountText); // Add text to the scene
        playerBetAmountText = new Text("Player bet amount: " + state.getPlayerBetAmount());
        playerBetAmountText.getStyleClass().add("text-display"); // Apply CSS class
        root.getChildren().add(playerBetAmountText); // Add text to the scene
        root.getChildren().add(aiLastMove); // Add text to the scene
        

        // Create the buttons
        dealButton = new Button("Deal Cards");
        dealButton.setOnAction(event -> {
        System.out.println("Deal button clicked!");
        deal(state);
        });
        betButton = new Button("Bet Cards");
        betButton.setOnAction(event -> {
        System.out.println("Bet button clicked!");
        bet(state);
        });
        betButton = new Button("Bet 10");
        betButton.setOnAction(event -> {
        System.out.println("Bet button clicked!");
        bet(state);
        });
        checkButton = new Button("Check");
        checkButton.setOnAction(event -> {
        System.out.println("Check button clicked!");
        playerCheck();
        });
        raiseButton = new Button("Raise");
        raiseButton.setOnAction(event -> {
        System.out.println("Raise button clicked!");
        playerRaise();
        });
        callButton = new Button("Call");
        callButton.setOnAction(event -> {
        System.out.println("Call button clicked!");
        playerCall();
        });
        foldButton = new Button("Fold");
        foldButton.setOnAction(event -> {
        System.out.println("Fold button clicked!");
        playerFold();
        });
        // Add the buttons to the root layout
        root.getChildren().add(dealButton);
        root.getChildren().add(betButton);
        root.getChildren().add(foldButton);
        root.getChildren().add(checkButton);
        root.getChildren().add(raiseButton);
        root.getChildren().add(callButton);

        updateButtons(); //updates the buttons


    }

    private void addMouseHandler(GameState state)
    {
        root.setOnMouseClicked(event -> {
            System.out.println("Mouse clicked!");
           // deal(state);
        });
    }

    private void clearTable()
    {
        table.getChildren().removeIf(node -> node instanceof ImageView);
    }

    private void deal(GameState state)
    {
        try{
            System.out.println("resetting game");
            //state.resetGame();
            System.out.println("game reset");
        }catch(Exception e)
        {
            System.out.println("Error resetting game: " + e.getMessage());
            e.printStackTrace();

        }
        
        state.setPokerState(PokerState.DEALING); //pokerstate = dealing 
        clearTable(); //resets the table
        Deck d = new Deck(); //gets a new deck
        d.shuffle(); //shuffles the deck
        for (int i = 1; i <=9; i++)
        {
            Card card = d.draw(); 
            //add cards to state and the pile
            if(i<=3)
            {
                state.addFlopCard(card); //adds the card to the flop
                placeCard(null, i);
            }
            else if(i ==4)
            {
                state.setTurnCard(card);
                placeCard(null, i);
            }
            else if(i ==5)
            {
                state.setRiverCard(card);
                placeCard(null, i);
            }
            else if(i ==6 || i ==7)
            {
                state.addPlayerCard(card);
                placeCard(card, i);
            }
            else if(i ==8 || i ==9)
            {
                state.addAiCard(card);
                placeCard(null, i);
            }

        }
        
        state.setPlayerValue(findValue(state, state.getPlayerCards())); //sets the player value
        state.setAiValue(findValue(state, state.getAiCards())); //sets the ai value 
        state.setPokerState(PokerState.BETTING);
        updateText();
        updateButtons();
        System.out.println(state.toString());
    }

    private void updateCards()
    {
        /*
         * updates cards based on the turn
         * 1,2,3 are the flop
         * 4 is the turn
         * 5 is the river
         * 6 is the player's first card
         * 7 is the player's second card
         * 8 is the opponent's first card
         * 9 is the opponent's second card
         */
        switch(state.getPokerState())
        {
            case FLOP:
                clearTable();
                //flop cards
                placeCard(state.getFlopDeck().get(0), 1);
                placeCard(state.getFlopDeck().get(1), 2);
                placeCard(state.getFlopDeck().get(2), 3);
                //turn card
                placeCard(null, 4);
                //river card
                placeCard(null, 5);
                //player cards
                placeCard(state.getPlayerCards().get(0), 6);
                placeCard(state.getPlayerCards().get(1), 7);
                //ai cards
                placeCard(null, 8);
                placeCard(null, 9);
                break;
            case TURN:
                clearTable();
                //flop cards
                placeCard(state.getFlopDeck().get(0), 1);
                placeCard(state.getFlopDeck().get(1), 2);
                placeCard(state.getFlopDeck().get(2), 3);
                //turn card
                placeCard(state.getTurnCard(), 4);
                //river card
                placeCard(null, 5);
                //player cards
                placeCard(state.getPlayerCards().get(0), 6);
                placeCard(state.getPlayerCards().get(1), 7);
                //ai cards
                placeCard(null, 8);
                placeCard(null, 9);
                break;
            case RIVER:
                clearTable();
                //flop cards
                placeCard(state.getFlopDeck().get(0), 1);
                placeCard(state.getFlopDeck().get(1), 2);
                placeCard(state.getFlopDeck().get(2), 3);
                //turn card
                placeCard(state.getTurnCard(), 4);
                //river card
                placeCard(state.getRiverCard(), 5);
                //player cards
                placeCard(state.getPlayerCards().get(0), 6);
                placeCard(state.getPlayerCards().get(1), 7);
                //ai cards
                placeCard(null, 8);
                placeCard(null, 9);
                break;
            case SHOWDOWN:
                clearTable();
                //flop cards
                placeCard(state.getFlopDeck().get(0), 1);
                placeCard(state.getFlopDeck().get(1), 2);
                placeCard(state.getFlopDeck().get(2), 3);
                //turn card
                placeCard(state.getTurnCard(), 4);
                //river card
                placeCard(state.getRiverCard(), 5);
                //player cards
                placeCard(state.getPlayerCards().get(0), 6);
                placeCard(state.getPlayerCards().get(1), 7);
                //ai cards
                placeCard(state.getAiCards().get(0), 8);
                placeCard(state.getAiCards().get(1), 9);
                break;
            default:
                break;
        }
    }

    private MenuBar createMenuBar()
    {
        MenuBar menuBar = new MenuBar();
    	menuBar.getStyleClass().add("menubar");

        //
        // File Menu
        //
    	Menu fileMenu = new Menu("File");

        addMenuItem(fileMenu, "Load from file", () -> {
            //System.out.println("Load from file");
            showLoadPopup();
            System.out.println(state.toString());
            
        });
        addMenuItem(fileMenu, "Save Load", () -> {
            saveGameState();
            //System.out.println(state.toString());
            
        });
        addMenuItem(fileMenu, "New Game", () -> {
            state.resetGame();
            updateButtons();
            clearTable();
            updateText();
            //System.out.println(state.toString());
            
        });

        menuBar.getMenus().add(fileMenu);

        return menuBar;
    }

    private static Map<Card, ImageView> cardImageViews = new HashMap<>();

    private static ImageView getBackOfCard()
    {
        // we need a new one every time
        return new ImageView(new Image(App.class.getResource("/assets/Back.png").toExternalForm()));
    }

    private static ImageView getCardImageView(Card card)
    {
        if (card == null)
        {
            return getBackOfCard();
        }
        if (!cardImageViews.containsKey(card))
        {
            String cardName = card.toString();
            String cardPath = "/assets/" + cardName + ".png";
            System.out.println("cardPath: " + cardPath);
            URL cardURL = App.class.getResource(cardPath);
            Image cardImage = new Image(cardURL.toExternalForm());
            ImageView cardImageView = new ImageView(cardImage);
            cardImageViews.put(card, cardImageView);
        }
        return cardImageViews.get(card);
    }

    private void placeCard(Card card, int number)
    {
        /*
         * The xOffset and yOffset are in terms of where the card should be placed
         * By default a StackPane will center the card at W/2, 0, so the center of the top
         * 1,2,3 are the flop
         * 4 is the turn
         * 5 is the river
         * 6 is the player's first card
         * 7 is the player's second card
         * 8 is the opponent's first card
         * 9 is the opponent's second card
         */
        int xOffset = 0;
        int yOffset = 0;
        switch (number)
        {
            case 1:
                xOffset = -2*64;
                yOffset = height/2 - 100;
                break;
            case 2:
                xOffset = -64;
                yOffset = height/2 - 100;
                break;
            case 3:
                xOffset = 0;
                yOffset = height/2 - 100;
                break;
            case 4:
                xOffset = 64;
                yOffset = height/2 - 100;
                break;
            case 5:
                xOffset = 2*64;
                yOffset = height/2 - 100;
                break;
            case 6:
                xOffset = -32;
                yOffset = height - 150;
                break;
            case 7:
                xOffset = 32;
                yOffset = height - 150;
                break;
            case 8:
                xOffset = -32;
                yOffset = 0;
                break;
            case 9:
                xOffset = 32;
                yOffset = 0;
                break;
            default:
                throw new IllegalArgumentException("Invalid card number: " + number);
        }

        ImageView cardImageView = getCardImageView(card);
        cardImageView.setTranslateX(xOffset);
        cardImageView.setTranslateY(yOffset);
        table.getChildren().add(cardImageView);
    }

    private void addMenuItem(Menu menu, String name, Runnable action)
    {
        MenuItem menuItem = new MenuItem(name);
        menuItem.setOnAction(event -> action.run());
        menu.getItems().add(menuItem);
    }

    private void addKeyHandler()
    {
        root.setOnKeyPressed(event -> {
            System.out.println("Key pressed: " + event.getCode());
            switch (event.getCode())
            {
                // check for the key input
                case ESCAPE:
                    // remove focus from the textfields by giving it to the root VBox
                    root.requestFocus();
                    System.out.println("You pressed ESC key");
                    break;
                case ENTER:
                    System.out.println("You pressed ENTER key");
                    break;
                default:
                    System.out.println("you typed key: " + event.getCode());
                    break;
                
            }
        });
    }



    public static void main(String[] args) 
    {
        launch(args);
    }

    private int findValue(GameState state, List<Card> hand) {
        System.out.println("Finding Value");

        List<Card> flopDeck = state.getFlopDeck();
        Card riverCard = state.getRiverCard();
        Card turnCard = state.getTurnCard();

        List<Card> allCards = new ArrayList<>(hand);
        allCards.addAll(flopDeck);
        allCards.add(riverCard);
        allCards.add(turnCard);

        Map<String, Integer> rankCount = new HashMap<>();
        Map<String, Integer> suitCount = new HashMap<>();
        List<Integer> rankValues = new ArrayList<>();

        for (Card card : allCards) {
            String rank = card.getRank(card);  
            String suit = card.getSuit(card);  

            rankCount.put(rank, rankCount.getOrDefault(rank, 0) + 1);
            suitCount.put(suit, suitCount.getOrDefault(suit, 0) + 1);
            rankValues.add(getRankValue(rank));  // Convert rank to numerical value
        }

        Collections.sort(rankValues);

        int handValue = evaluateHand(rankCount, suitCount, rankValues);

        //System.out.println("Hand Value: " + handValue);
        return handValue;
    }

    private int evaluateHand(Map<String, Integer> rankCount, Map<String, Integer> suitCount, List<Integer> rankValues) {
        boolean flush = suitCount.values().stream().anyMatch(count -> count >= 5);
        boolean straight = checkStraight(rankValues);
        boolean royal = straight && rankValues.contains(14) && flush;

        if (royal) return 100; // Royal flush
        if (flush && straight) return 90; // Straight flush
        if (rankCount.containsValue(4)) return 80; // Four of a kind
        if (rankCount.containsValue(3) && rankCount.containsValue(2)) return 70; // Full house
        if (flush) return 60; // Flush
        if (straight) return 50; // Straight
        if (rankCount.containsValue(3)) return 40; // Three of a kind
        if (Collections.frequency(rankCount.values(), 2) == 2) return 30; // Two pairs
        if (rankCount.containsValue(2)) return 20; // One pair

        return rankValues.get(rankValues.size() - 1); // Highest card
    }


    // Checks for a straight
    private boolean checkStraight(List<Integer> rankValues) {
        int count = 1;
        for (int i = 1; i < rankValues.size(); i++) {
            if (rankValues.get(i) == rankValues.get(i - 1) + 1) {
                count++;
                if (count >= 5) return true;
            } else if (rankValues.get(i) != rankValues.get(i - 1)) {
                count = 1;
            }
        }
        return false;
    }


    // Converts rank to numerical value
    private int getRankValue(String rank) {
    switch (rank) {
        case "A": return 14;
        case "K": return 13;
        case "Q": return 12;
        case "J": return 11;
        case "T": return 10;
        default: return Integer.parseInt(rank);
    }
    }

    private void bet(GameState state)
    {
        state.setLastMove(Actions.BET);
        handleAiTurn();
        state.setPlayerBetAmount(10);
        state.setAiBetAmount(10);
        state.setPokerState(PokerState.FLOP);
        updateText();
        updateButtons();
        updateCards();
        System.out.println(state.toString());
    }

    private void playerRaise()
    {
        //adds 10 t0 the bet amount
        state.setPlayerBetAmount(state.getPlayerBetAmount()+10);
        System.out.println("Raise");
        state.setLastMove(Actions.RAISE);
        handleAiTurn();
        updateButtons();
        updateText();
        gameOver();
    }

    private void playerFold()
    {
        //forfits the game
        System.out.println("Fold");
        state.setOutcome(PokerState.AI_WINS);
        //state.setLastMove(Actions.FOLD);
        updateButtons();
        updateText();
        System.out.println(state.toString());
        state.setPokerState(PokerState.SHOWDOWN);
        nextTurn();
        gameOver();
    }

    private void playerCheck()
    {
        
        //doesnt raise stays the same
        System.out.println("Check");
        //checks if the last Ai move was check before setting last move to check
        if(state.getLastMove().equals(Actions.CHECK))
        {
            state.setLastMove(Actions.CHECK);
            nextTurn();
        }
        else
        {
            //if the ai's last turn isnt check
            state.setLastMove(Actions.CHECK);
            handleAiTurn();
            //if the ai desides to check after you do
            if(state.getLastMove().equals(Actions.CHECK))
            {
                nextTurn();
            }
        }
        updateButtons();
        updateText();
    }

    private void playerCall()
    {
        //matches the bet
        System.out.println("call");
        state.setLastMove(Actions.CALL);
        handleAiTurn();
        updateButtons();
        updateText();
    }

    private void handleAiTurn() {
        AiCalq aiCalculator = new AiCalq(state); // Pass GameState instance
        aiCalculator.aiDecision(); //Ai makes decision
        if(state.getLastMove().equals(Actions.FOLD))
        {
            state.setPokerState(PokerState.SHOWDOWN);
            nextTurn();
            gameOver();
        }
    }

    private void updateText()
    {
        //valueText.setText("AI Value: " + state.getAiValue() + " | Player Value: " + state.getPlayerValue()); 
        //gameStateText.setText("Current Game State: " + state.getPokerState());
        aiBetAmountText.setText("Opponent bet amount: " + state.getAiBetAmount());
        playerBetAmountText.setText("Player bet amount: " + state.getAiBetAmount());
        balanceText.setText("Balance: " + state.getBalance());
        if(state.getLastMove() != null)
        {
            if(!state.getLastMove().equals(Actions.WAITING))
            {
                aiLastMove.setText("Opponent's last move: " + state.getLastMove()); //this has to be called after the ai goes
            }
            else
            {
                aiLastMove.setText("Opponent's last move: "); //makes it blank in case yoy have to restart the game
            }
        }
    }

    private void updateButtons()
    {
        //dealbutton
        if (state.getPokerState().equals(PokerState.WAITING_TO_START))
        {
            dealButton.setVisible(true);
        }
        else
        {
            dealButton.setVisible(false);
        }
        //betbutton
        if (state.getPokerState().equals(PokerState.BETTING))
        {
            betButton.setVisible(true);
        }
        else
        {
            betButton.setVisible(false);
        }
        switch(state.getLastMove())
        {
            case RAISE:
                callButton.setVisible(true);
                raiseButton.setVisible(true);
                foldButton.setVisible(true);
                checkButton.setVisible(false);
                break;
            case CALL:
                raiseButton.setVisible(true);
                foldButton.setVisible(true);
                checkButton.setVisible(true);
                callButton.setVisible(false);
                break;
            case CHECK: 
               raiseButton.setVisible(true);
                foldButton.setVisible(true);
                checkButton.setVisible(true);
                callButton.setVisible(false);
                break;
            case FOLD:
                raiseButton.setVisible(false);
                foldButton.setVisible(false);
                checkButton.setVisible(false);
                callButton.setVisible(false);
                break;
            case BET:
                raiseButton.setVisible(false);
                foldButton.setVisible(false);
                checkButton.setVisible(false);
                callButton.setVisible(false);
                break;
            default:
                raiseButton.setVisible(false);
                foldButton.setVisible(false);
                checkButton.setVisible(false);
                callButton.setVisible(false);
                break;
        }
        
    }

    private void gameOver()
    {   
        //game over should have popups
        switch(state.getOutcome())
        {
            case PLAYER_WINS:
                //open a popup that starts a new game or quits
                state.setBalance(state.getBalance() + state.getPlayerBetAmount());
                //System.out.println("Player wins");
                updateButtons();
                updateText();
                updateCards();
                showGameResultPopup("Player Wins");
                break;
            case AI_WINS:
                state.setBalance(state.getBalance() - state.getPlayerBetAmount());
                updateButtons();
                updateText();
                updateCards();
                //opens a popup that starts a new game or quits
                showGameResultPopup("Ai Wins");
                break;
            case DRAW:
                updateButtons();
                updateText();
                updateCards();
                showGameResultPopup("Draw");
                //opens a popup that states that its a draw and to start a new game or quit
            default:
                break;//does nothing of game is anything else but over
        }
    }

    private void whoWins()
    {
        if(state.getAiValue() > state.getPlayerValue())
        {   
            state.setOutcome(PokerState.AI_WINS);
            //System.out.println("ai wins");
        }
        else if(state.getAiValue() < state.getPlayerValue())
        {
            state.setOutcome(PokerState.PLAYER_WINS);
            //System.out.println("Player wins");
        }
        else if(state.getAiValue() == state.getPlayerValue())
        {
            state.setOutcome(PokerState.DRAW);
            //System.out.println("draw");
        }
        gameOver();
    }

    private void nextTurn()
    {
        //will look at the current turn and change it to the next turn
        //pre flop > flop > turn > river > showdown
        switch(state.getPokerState())
        {
            case FLOP:
                state.setPokerState(PokerState.TURN);
                System.out.println("turn = turn");
                updateCards();
                break;
            case TURN:
                state.setPokerState(PokerState.RIVER);
                System.out.println("turn = river");
                updateCards();
                break;
            case RIVER:
                state.setPokerState(PokerState.SHOWDOWN);
                System.out.println("turn = showdown");
                updateCards();
                whoWins();
                break;
            default://nothing happens
                break;
        }
    }

    public void saveGameState() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("src\\\\main\\\\java\\\\game\\\\template\\\\save.txt", true))) {
            writer.write(state.toString() + "\n"); // Manually add newline character
            System.out.println("Game state saved successfully to save.txt");
        } catch (IOException e) {
            System.err.println("Error saving game state: " + e.getMessage());
        }
    }




    public void loadGameState() {
        try (BufferedReader reader = new BufferedReader(new FileReader("src\\main\\java\\game\\template\\save.txt"))) {
            String line = reader.readLine();
            if (line != null && line.startsWith("GameState{")) {
                line = line.replace("GameState{", "").replace("}", "");
                String[] parts = line.split(", ");

                for (String part : parts) {
                    String[] keyValue = part.split("=");
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();

                        switch (key) {
                            case "pokerState":
                                state.setPokerState(PokerState.valueOf(value));
                                break;
                            case "outcome":
                                state.setOutcome(PokerState.valueOf(value));
                                break;
                            case "aiValue":
                                state.setAiValue(Integer.parseInt(value));
                                break;
                            case "playerValue":
                                state.setPlayerValue(Integer.parseInt(value));
                                break;
                            case "playerBetAmount":
                                state.setPlayerBetAmount(Integer.parseInt(value));
                                break;
                            case "aiBetAmount":
                                state.setAiBetAmount(Integer.parseInt(value));
                                break;
                            case "balance":
                                state.setBalance(Integer.parseInt(value));
                                break;
                            case "lastMove":
                                state.setLastMove(Actions.valueOf(value));
                                break;
                            case "aiCards":
                                for (Card card : parseCardList(value)) {
                                    state.addAiCard(card);
                                }
                                break;
                            case "playerCards":
                                for (Card card : parseCardList(value)) {
                                    state.addAiCard(card);
                                }
                            case "flopDeck":
                                for (Card card : parseCardList(value)) {
                                    state.addAiCard(card);
                                }
                                break;
                            case "turnCard":
                                state.setTurnCard(Card.valueOf(value)); // Correctly assigning enum
                                break;
                            case "riverCard":
                                state.setRiverCard(Card.valueOf(value)); // Correctly assigning enum
                                break;
                        }
                    }
                }
                updateButtons();
                updateText();
                updateCards();
                System.out.println("Game state loaded successfully from save.txt");
            }
        } catch (IOException | IllegalArgumentException e) {
            System.err.println("Error loading game state: " + e.getMessage() + " starting new game");

        }
    }

    private List<Card> parseCardList(String value) {
        List<Card> cards = new ArrayList<>();
        value = value.replace("[", "").replace("]", ""); // Remove brackets
        String[] cardNames = value.split(",");

        for (String cardName : cardNames) {
            cardName = cardName.trim();
            if (!cardName.isEmpty()) {
                cards.add(Card.fromString(cardName)); // Convert string to Card enum
            }
        }
        return cards;
    }

    //popups


    public void showLoadPopup() {
        List<String> savedGames = readSavedGames(); // Get all saved entries

        if (savedGames.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle("Load Game");
            alert.setHeaderText(null);
            alert.setContentText("No saved games found.");
            alert.showAndWait();
            return;
        }

        ChoiceDialog<String> dialog = new ChoiceDialog<>(savedGames.get(0), savedGames);
        dialog.setTitle("Load Game");
        dialog.setHeaderText("Select a saved game to load:");
        dialog.setContentText("Saved Games:");

        Optional<String> result = dialog.showAndWait();
        result.ifPresent(selectedSave -> {
            loadGameState();
            System.out.println("Loaded selected game: " + selectedSave);
        });
    }

    // Reads all saved game states from the file
    private List<String> readSavedGames() {
        List<String> saves = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader("src\\\\main\\\\java\\\\game\\\\template\\\\save.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                saves.add(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading saved games: " + e.getMessage());
        }
        return saves;
    }

    public void showGameResultPopup(String resultMessage) {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setTitle("Game Over");
        alert.setHeaderText(resultMessage);
        alert.setContentText("Your balance: $" + state.getBalance() + "\nDo you want to play again?");
        
        ButtonType playAgainButton = new ButtonType("Play Again");
        ButtonType quitButton = new ButtonType("Quit");
        
        alert.getButtonTypes().setAll(playAgainButton, quitButton);
        
        Optional<ButtonType> result = alert.showAndWait();
        if (result.isPresent() && result.get() == playAgainButton) {
            state.newGame();
            System.out.println("Starting a new game...");
            clearTable();
            updateButtons();
            updateText();
        } else {
            System.out.println("Exiting...");
            System.exit(0); // Quits the application
        }
    }


}
